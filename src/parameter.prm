## Program to the bachelor thesis:  
## "On a String Partitioning Problem"
## Institut für Informatik, 
## Department of Algorithmische Bioinformatik
## Heinrich Heine Univversity Düsseldorf, Germany
## written by: Michael Wulfert, matriculation number 2555304
#--------- --------- --------- --------- --------- ---------|--------- --------|

# parameter for the string processor to control:
    
# standard input if no argument is given
standardInput = TestSeqShort.seq 
# 				AAAABAACCCCCCAAABAADDEDD
standardInput = TestSeq.seq  
#standardInput = ABAACCCDDEEDDEEDDEECCBABABBB
#standardInput = DDABCCBBCBAADDD
#standardInput = ABAACDEDEDCAABAA
#standardInput = ABCDDCCBBAA
#standardInput = MNMNOOOPPPPQQQNMMM
#standardInput = ABAABBCDDDDDCCBBBAAA

# result has all optimal strings or only one
showAllOptima = True

# result must have every letter
everyLetterExists = False


# methods:
# tree = tree   # binary decision tree
# walk = walk   # random walk through tree
# wide = wide   # wide decision tree
# dag  = dag    # directed acyclic graph, ideal for small alphabets
# ilp  = ilp    # Integer Linear Programming, uses pulp
method = dag
    
# Reductions:
# -----------

# Reduction 1
# group blocks of identical letters
blockIdenticalLetters = True

# Reduction 2:
# consider independent sublists
independentSublists = True

# Reduction 2a: Stronger than reduction 2
# consider internal sublists
internalSublists = True

# Reduction 3:
# break iteration branch if maximum is not longer reachable
breakIfTooSmall = True

# Reduction 4:
# break iteration branch if maximum is not longer reachable
tooManyToReject = True

# Reduction 5:
# take only 'new' letters - avoids leading blocks of same letter missing
takeOnlyNewLetters = True

# Reduction 6:
# take contiguous unique blocks together
uniquesTogether = True

# Reduction 7:
# no more letters left
noMoreLetters = True

# Reduction 8: (unnecessary)
# take last possible letter
takeLastLetter = True

# Reduction 9:
# minimum of letters to reject in the remaining string
minToReject = True
    
 
    
# Heuristics (only for tree algorithm):
# If bifurcation possible: choose one randomly
randomTreeWalk = False
randomTreeRepeats = 10000
randomTreeProbability = 0.5
    
    
# Outputs:
# --------

onyResultString     = True

# print sublists
printSublist        = False
reportPossibilities = True
printMethod         = False

# tree: recursion steps: no False after True!
printRecursionSteps = True
printRecursionBreak = True
printRecursionStop  = False
# for walk histograms:
countStringLengths  = False

# ILP:
printILPsteps     = False
printILPequations = False
printILPresults   = False

#DAG
printNewListLetter     = False
printLetterLists       = False
printLetterComparisons = False
printNewMaxima         = False
printDAG               = False
#dag - debug
pointerPosResetExit    = False


# results
printInputBlocks          = True
printIndependentSublists  = True
printSubstringResults     = False
printLongSummary          = False
printShortSummary         = True
printResultList           = True
printRuntimes             = True

